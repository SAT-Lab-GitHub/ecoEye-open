#this exports blobs from images present on the board, based on the blob coordinates given inside CSVs named after the picture ID
#due to memory limitations on the H7+, it is not possible to load the original, large detection.CSV files usually generated by camera deployments, and we cannot have much more than 1000 images + their CSVs on the SD card
#instead, we generate separate CSVs for each image file with the R script "split detections by picture id.R" and save them on the SD card
# TODO: extract the right data explicitly, without using numeric column indices
#originally based on a script that Sheng Dong wrote

#import libraries
import sensor, image, time, os, pyb, machine, sys

######### USER-DEFINED SETTINGS
#pic_id, detec_id, x,y,w,h tuple
nan = -1
#export blobs as bounding squares (preserves proportions to help image classification)
blob_bounding_square=True

######### END of USER-DEFINED SETTINGS

#set constants
GREEN_LED_PIN = 2

#scan card contents
files=os.listdir()

#create crop directory
if not "blobs" in files:
    os.mkdir("blobs")
    print("Created blobs directory")

#print(files)
jpegs=[files for files in files if "jpg" in files]
print("Found",len(jpegs),"JPEGs in root")

#open each jpeg
for jpeg in jpegs:
    print(" *** Loading:",jpeg,"...")
    img_ori=image.Image(jpeg,copy_to_fb=True)
    #print(img_ori)

    #get dimensions of image for square blob calculations
    image_width=img_ori.width()
    image_height=img_ori.height()
    print(jpeg,":",image_width,"px wide,",image_height,"px high")

    #extract picture ID
    pic_id = jpeg.split('.')[0]

    #get rois from corresponding CSV
    rois = []
    with open('./'+pic_id+'.csv') as csvfile:
        for row in csvfile:
            #split each row by comma
            rois.append(row.split(','))
    #remove first row (header row)
    del rois[0]
    print("Comma-split detection rows data for picture:",jpeg,":",rois)

    #loop over blobs that were found for this image
    for roi_temp in rois:
        #print("ROI temp:",roi_temp)

        if nan in roi_temp:
            continue

        try:
            #extract blob rectangle coordinates
            x_temp=min(int(roi_temp[2]),int(roi_temp[4]),int(roi_temp[6]),int(roi_temp[8]))
            #print("x:",x_temp)
            y_temp=min(int(roi_temp[3]),int(roi_temp[5]),int(roi_temp[7]),int(roi_temp[9]))
            #print("y:",y_temp)
            x_max_temp=max(int(roi_temp[2]),int(roi_temp[4]),int(roi_temp[6]),int(roi_temp[8]))
            y_max_temp=max(int(roi_temp[3]),int(roi_temp[5]),int(roi_temp[7]),int(roi_temp[9]))
            width_temp=x_max_temp-x_temp
            #print("w:",width_temp)
            height_temp=y_max_temp-y_temp
            #print("h:",height_temp)

            #export squares
            if (blob_bounding_square):
                #get longest side of blob's bounding rectangle
                if (width_temp>=height_temp):
                    height_temp=width_temp
                if (height_temp>width_temp):
                    width_temp=height_temp
                if (height_temp>image_height):
                    print("Cannot export blob bounding square as its height would exceed the image height! Using image height instead.")
                    height_temp=image_height
                #get new coordinates depending on location of blob relative to border
                if (x_temp==0):
                    x_temp=0
                elif (x_temp+width_temp>=image_width):
                    x_temp=image_width-width_temp
                if (y_temp==0):
                    y_temp=0
                elif (y_temp+height_temp>=image_height):
                    y_temp=image_height-height_temp

            #construct bounding rectangle
            blob_rect = (x_temp,y_temp,width_temp,height_temp)
            print("Extracting blob bounding rectangle:",blob_rect,"(xywh) from",jpeg)

            #deallocate frame buffer (to be sure)
            sensor.dealloc_extra_fb()
            #allocate frame buffer to new blob
            img_blob=sensor.alloc_extra_fb(width_temp, height_temp, sensor.RGB565)
            #save blob to that new frame buffer (to avoid changing object in place)
            img_ori.to_rgb565(roi=blob_rect,copy=img_blob)

            #export blob bounding rectangle
            pyb.LED(GREEN_LED_PIN).on()
            img_blob.save("blobs/"+str(pic_id)+"_d"+str(roi_temp[0])+'_xywh'+str(blob_rect)+".jpg",quality=95)
            pyb.LED(GREEN_LED_PIN).off()
        except:
            print('Failed: ' + jpeg + ', blob id=' + roi_temp[0])
